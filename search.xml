<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TypeScript - TypeScript基础学习</title>
      <link href="2021/01/28/TypeScript-TypeScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/01/28/TypeScript-TypeScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WX - 微信原生转化Uni-App</title>
      <link href="2021/01/28/wxMp-To-Uni/%E5%8E%9F%E7%94%9F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8C%96UniApp/"/>
      <url>2021/01/28/wxMp-To-Uni/%E5%8E%9F%E7%94%9F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8C%96UniApp/</url>
      
        <content type="html"><![CDATA[<h4 id="一、它是谁？"><a href="#一、它是谁？" class="headerlink" title="一、它是谁？"></a>一、它是谁？</h4><p>【miniprogram-to-uniapp】转换微信小程序”项目为uni-app项目。<br>原则上混淆过的项目，也可以进转换，因为关键字丢失，不一定会完美。</p><h4 id="二、它的原理是什么？"><a href="#二、它的原理是什么？" class="headerlink" title="二、它的原理是什么？"></a>二、它的原理是什么？</h4><p>最初是学了半节课堆和栈，觉得词法分析挺有意思的，再加入转换小程序插件时，发现这些繁琐的操作完全可以使用程序来完成。<br>核心是使用Babel获取AST（词法分析)，然后或使用Babel自带函数增删，或正则分析替换等等操作。<br>可能有的朋友觉得，这种为啥不是纯正则分析？ 纯正则可以解决一部分问题，对于标签与标签内容，其实正则是很难进行区分的哈。</p><h4 id="三、它能做哪些事情？"><a href="#三、它能做哪些事情？" class="headerlink" title="三、它能做哪些事情？"></a>三、它能做哪些事情？</h4><p>支持无云开发的小程序项目转换为uni-app项目<br>支持有云开发的小程序项目转换为uni-app项目(cloudfunctions目录将被忽略，uni-app结合小程序云开发见：使用uni-app进行微信小程序云开发经验分享)<br>支持解析TypeScript小程序项目<br>支持解析使用npm模块的小程序项目<br>支持解析include标签<br>支持解析template标签<br>支持解析Behavior文件为mixins文件<br>支持.js’, .wxml和*.wxss文件进行相应转换，并做了大量的优化<br>支持识别App、Page、Component、VantComponent、Behavior和纯Javascript文件的转换<br>使用jyf-parser替换wxParse(感谢网友 “爱瑞巴勒康忙北鼻” 的建议)<br>搜索未在data声明，而直接在setData()里使用的变量，并修复<br>合并使用require导入的wxs文件<br>因uni-app会将所有非static目录的资源文件删除，因此将所有资源文件移入static目录，并修复所有能修复到的路径<br>修复变量名与函数重名的情况(目前uni编译时会将非static目录的文件复制一份到static目录，但并不完全，因此本功能仍保留)<br>支持wxs文件转换，可以通过参数配置(-w)，默认为false(目前uni-app已支持wxs，不再推荐转换wxs)<br>支持vue-cli模式，可以通过参数配置(-c)，默认为false，即生成为vue-cli项目，转换完成需运行npm -i安装包，然后再导入hbuilder x里开发(建议爱折腾人士使用)<br>支持vant转换，可以通过参数配置(-z)，默认为false：自动识别（无须添加参数，工具已支持自动识别vant项目），如果需要转换使用vant-weapp组件的小程序项目，必须配置这个参数，否则转换后有问题。（另外，转换后的项目，目前仅支持v3和h5两个平台）<br>支持wx.xxx()转换为uni.xxx()，可以通过参数配置(-r)，默认为false（因uni已经对wx相关函数做了兼容，但仍有很多朋友有此需求，特作为可配置项，按需自取）</p><h4 id="四、它还有哪些不支持转换？"><a href="#四、它还有哪些不支持转换？" class="headerlink" title="四、它还有哪些不支持转换？"></a>四、它还有哪些不支持转换？</h4><p>不支持替换：wxaSortPicker<br>setData的变量是props里定义的<br>抽象节点：componentGenerics<br>语法错误(原始代码就有语法错误，请仔细检查，工具无法帮助你将所有代码都修复)<br>更多请参见miniprogram to uniapp 工具答疑</p><h4 id="五、怎么使用？"><a href="#五、怎么使用？" class="headerlink" title="五、怎么使用？"></a>五、怎么使用？</h4><h5 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h5><p>在命令行里，运行【 npm install miniprogram-to-uniapp -g 】进行安装，因为这个包是工具，要求全局都能使用，所以需要-g进行全局安装。<br>如果运行npm报错，请先安装Node.js，下载地址：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p><p><img src="https://res.cloudinary.com/dt3vcmqdt/image/upload/v1612410294/%E5%B0%8F%E7%A8%8B%E5%BA%8F/1_jvieea.png" alt=""></p><h5 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h5><p>继续在命令行里，运行【 wtu -V 】，执行结果如下：</p><p><img src="https://res.cloudinary.com/dt3vcmqdt/image/upload/v1612410295/%E5%B0%8F%E7%A8%8B%E5%BA%8F/2_imxt7p.png" alt=""></p><p>显示版本号，说明已经安装成功了。（wtu -&gt; 取自wx to uni之意，后面都用这个全局命令）</p><h5 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h5><p>在命令行里，输入【wtu -i “你的小程序项目路径”】<br>注意 -i 前面和后面都有空格！！！<br>注意 -i 前面和后面都有空格！！！<br>注意 -i 前面和后面都有空格！！！<br>如：【wtu -i “E:\zpWork\Project_self\miniprogram-to-uniapp\test\test-wx-to-uni”】 ，回车后即可以在源项目同及目录得到一个后缀为_uni的目录，即转换成功。</p><p>转换前：</p><p><img src="https://res.cloudinary.com/dt3vcmqdt/image/upload/v1612410297/%E5%B0%8F%E7%A8%8B%E5%BA%8F/3_rrzqx9.png" alt=""></p><p>转换后：</p><p><img src="https://res.cloudinary.com/dt3vcmqdt/image/upload/v1612410299/%E5%B0%8F%E7%A8%8B%E5%BA%8F/4_l1gfdc.png" alt=""></p><p>转换后的项目文件对比（左边是小程序项目，右边是Uni-app项目目录）：</p><p><img src="https://res.cloudinary.com/dt3vcmqdt/image/upload/v1612410300/%E5%B0%8F%E7%A8%8B%E5%BA%8F/5_bwa9fk.png" alt=""></p><h5 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h5><p>将转换后的xxx_uni项目导入到hbuilder X，<br>点击菜单 运行—&gt; 运行到小程序模拟器—&gt;微信开发者工具！（如果是使用了vant的项目，请运行到H5，vant项目转换后仅支持H5和app）<br>点击菜单 运行—&gt; 运行到小程序模拟器—&gt;微信开发者工具！（如果是使用了vant的项目，请运行到H5，vant项目转换后仅支持H5和app）<br>点击菜单 运行—&gt; 运行到小程序模拟器—&gt;微信开发者工具！（如果是使用了vant的项目，请运行到H5，vant项目转换后仅支持H5和app）<br>重要的话说三遍！<br>然后查看转换后的项目运行到小程序，是否可以正常运行无报错！<br>(因为这种转换非100%，所以至少需要保证 小程序—&gt;uniapp—&gt;小程序仍然能正常运行，再考虑运行到其他小程序或app)，<br>如有报错，请根据miniprogram to uniapp 工具答疑 进行修改，保证无报错，然后再运行到其他平台。</p><p>工具升级#<br>因为工具更新比较频繁，安装后，可以使用如下命令进行升级：<br>npm update miniprogram-to-uniapp -g</p><p>原文链接：<a href="https://ask.dcloud.net.cn/article/36037">https://ask.dcloud.net.cn/article/36037</a></p>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux - Linux命令行 光标移动技巧等</title>
      <link href="2021/01/22/Linux/keymap/"/>
      <url>2021/01/22/Linux/keymap/</url>
      
        <content type="html"><![CDATA[<p>看一个真正的专家操作命令行绝对是一种很好的体验-光标在单词之间来回穿梭，命令行不同的滚动。<br>在这里强烈建立适应GUI节目的开发者尝试一下在提示符下面工作。<br>但是事情也不是那么简单，还是需要知道“如何去做”。</p><h4 id="Ctrl组合"><a href="#Ctrl组合" class="headerlink" title="Ctrl组合"></a>Ctrl组合</h4><p>在单词之间跳转，使用Ctrl+左右键。<br>Ctrl+a跳到本行的行首<br>Ctrl+e则跳到页尾<br>Ctrl+u删除当前光标前面的文字<br>ctrl+k-删除当前光标后面的文字<br>Ctrl+w和Alt+d - 对于当前的单词进行删除操作，w删除光标前面的单词的字符，d则删除后面的字符<br>ctrl+a:光标移到行首<br>ctrl+b:光标左移一个字母<br>ctrl+c:杀死当前进程<br>ctrl+d:退出当前 Shell<br>ctrl+e:光标移到行尾<br>ctrl+h:删除光标前一个字符，同 backspace 键相同<br>ctrl+k:清除光标后至行尾的内容<br>ctrl+l:清屏，相当于clear<br>ctrl+r:搜索之前打过的命令。会有一个提示，根据你输入的关键字进行搜索bash的history<br>ctrl+u: 清除光标前至行首间的所有内容<br>ctrl+w: 移除光标前的一个单词<br>ctrl+t: 交换光标位置前的两个字符<br>ctrl+y: 粘贴或者恢复上次的删除<br>ctrl+d: 删除光标所在字母;注意和backspace以及ctrl+h的区别，这2个是删除光标前的字符<br>ctrl+f: 光标右移<br>ctrl+z : 把当前进程转到后台运行，使用’ fg ‘命令恢复。比如top -d1 然后ctrl+z ，到后台，然后fg,重新恢复</p><h4 id="Alt组合"><a href="#Alt组合" class="headerlink" title="Alt组合"></a>Alt组合</h4><p>Alt+Backsapce - 删除当前光标后面的单词，如果删除错误，使用Ctrl+y进行恢复Ctrl+L进行清屏操作</p><h4 id="ESC组合"><a href="#ESC组合" class="headerlink" title="ESC组合"></a>ESC组合</h4><p>esc+d: 删除光标后的一个词<br>esc+f: 往右跳一个词<br>esc+b: 往左跳一个词<br>esc+t: 交换光标位置前的两个单词。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git - Git个人学习记录手册</title>
      <link href="2021/01/21/Git/gitlearn/"/>
      <url>2021/01/21/Git/gitlearn/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon modern"><i class="note-icon fas fa-bullhorn"></i><p>本篇教程是自己学习Git记录的<br>本篇教程不会介绍Git背景以及一些专业知识，毕竟本人时间有限哈哈哈！<br>如果喜欢教程就评论下或者把站点添加到你宝贵的收藏夹里面吧</p></div><h3 id="一、安装Git"><a href="#一、安装Git" class="headerlink" title="一、安装Git"></a>一、安装Git</h3><p>​    本人是MacOS系统这里只是演示一下，如Linux 、windows 请自行查阅资料 我这里就不展开了哈。</p><h5 id="通过homebrew安装Git"><a href="#通过homebrew安装Git" class="headerlink" title="通过homebrew安装Git"></a>通过homebrew安装Git</h5><ul><li>未安装homebrew，需安装homebrew<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure></li><li>安装git<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure></li><li>安装完成后还需要进一步设置，打开你的终端输入：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</li></ul><p>注意git config命令的—global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h3 id="二、认识Git"><a href="#二、认识Git" class="headerlink" title="二、认识Git"></a>二、认识Git</h3><p>在学习Git需要清楚的几个术语<br><img src="https://res.cloudinary.com/dt3vcmqdt/image/upload/v1611215358/Git/683090701_88630_cxjbn1.png" alt=""></p><p><strong>Workspace</strong>：工作区<br><strong>Index/Stage</strong>：暂存区，也叫索引<br><strong>Repository</strong>：仓库区（或本地仓库），也存储库<br><strong>Remote</strong>：远程仓库</p><p><strong>1. 有关几个名词解释</strong></p><p><strong>工作区</strong>: 通过<code>git init</code>创建的代码库的所有文件但是不包括<code>.git</code>文件(版本库)<br><strong>暂存区</strong>: 通过<code>git add ./*/*Xxx/Xxxx*</code> 添加的修改,都是进入到暂存区了,肉眼不可见 通过 <code>git status</code> 可以看到修改的状态。</p><p><strong>2. 什么是修改？</strong><br>比如你新增了一行，这就是一个修改，<br>删除了一行，也是一个修改，<br>更改了某些字符，也是一个修改，<br>删了一些又加了一些，也是一个修改，<br>甚至创建一个新文件，也算一个修改。</p><h3 id="三、创建版本库"><a href="#三、创建版本库" class="headerlink" title="三、创建版本库"></a>三、创建版本库</h3><p>什么是版本库呢，以我的初中学历水平可以这样解释，可以理解版本库就是一个文件夹，这里面的文件等都会被git管理，谁也跑不掉除非你给某个文件手动排除在外这样git就不会管它了。<br>所以创建个版本库是不是特别简单了呢，看下面。（建个文件夹不久好了）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir learngit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> learngit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span></span></span><br><span class="line">/Users/aliang/learngit</span><br></pre></td></tr></table></figure><br><code>pwd</code>命令用于显示当前目录。在我的Mac上，这个仓库位于<code>/Users/aliang/learngit</code>。<br>好了文件夹建立好了，接下来吧文件夹交给git吧，我们需要通过这个命令<code>git init</code>来初始化git版本库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in &#x2F;Users&#x2F;aliang&#x2F;learngit&#x2F;.git&#x2F;</span><br></pre></td></tr></table></figure><br>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p><p>如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p><h5 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h5><p>言归正传，现在我们编写一个<code>readme.txt</code>文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建第一个文件---这是文件内容---</span><br></pre></td></tr></table></figure><br>一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p><p>把一个文件放到Git仓库只需要两步。</p><p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add readme.txt</span></span><br></pre></td></tr></table></figure><br>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p><p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;new aliang readme file&quot;</span></span></span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure><br>这样文件就添加进本地仓库了。<br>这小节一共学习了三个命令哦<br>初始化一个Git仓库，使用<code>git init</code>命令。</p><p>添加文件到Git仓库，分两步：</p><ul><li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件。</li><li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li></ul><h3 id="四、时光机器"><a href="#四、时光机器" class="headerlink" title="四、时光机器"></a>四、时光机器</h3><p>上一小节已经吧文件添加到本地仓库了，现在我们休息回来又要继续干活了，我们继续修改readme.txt 文件 随便改点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建第一个文件---这是文件内容---</span><br><span class="line">&#x2F;&#x2F;这里是你编写到代码嘿嘿嘿</span><br></pre></td></tr></table></figure><br>现在我们查看下改动结果使用<code>git status</code>命令来查看。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><br>如果想看文件都修改了什么内容怎么办，小问题git给我们提供了一个<code>git diff</code> 命令<br><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式,我这里就不演示了，有时候我看diff也懵逼。。。</p><p>接下来就是提交修改到本地仓库喽，还记得哈。<br>第一步是<code>git add</code>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add readme.txt</span></span><br></pre></td></tr></table></figure><br>同样没有任何输出。在执行第二步<code>git commit</code>之前，我们再运行<code>git status</code>看看当前仓库的状态：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><br>git status告诉我们，将要被提交的修改包括<code>readme.txt</code>，下一步，就可以放心地提交了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;add code&quot;</span></span></span><br><span class="line">[master e475afc] add code</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><br>提交后，我们再用<code>git status</code>命令看看仓库的当前状态：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><br>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。</p><h3 id="五、版本回退"><a href="#五、版本回退" class="headerlink" title="五、版本回退"></a>五、版本回退</h3><p>  ·今天先更新到这里，干活去喽 持续更新！！！·</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6 - Promise 基础教程使用</title>
      <link href="2021/01/15/JsLearn/Promise/"/>
      <url>2021/01/15/JsLearn/Promise/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天记录一篇ES6新知识 Promise<br>初次接触Promise 你可能会很懵逼 ，这TM是个什么玩意 ！康康过了官方文档之后也是一头雾水！！</p></blockquote><h5 id="话不多说，直接上干货"><a href="#话不多说，直接上干货" class="headerlink" title="话不多说，直接上干货"></a>话不多说，直接上干货</h5><ul><li>Promise到底是来做啥的呢？<ul><li>Promise 是异步编程的一种解决方案。</li></ul></li><li>那什么时候我们会来处理异步事件呢？<ul><li>一种很常见的场景应该就是网络请求了。</li><li>我们封装一个网络请求的函数，因为不能立即拿到结果，所以不能像3+7=10一样返回结果。</li><li>所以往往我们会传入另一个函数，在数据请求成功时候，将数据通过这个函数回调出去 ，这就是我们经常扯皮的回调函数。</li><li>如果只是一个简单的网络请求，那么这种方案还是可以的，比较可以接受。</li></ul></li><li><p>但是，当网络请求非常复杂的时候，就会出现回调地狱。</p><ul><li>Ok，接下来看】康康地狱吧</li></ul></li><li><p>我们来考虑下面的场景(有夸张的成分)：</p><ul><li>我们需要通过一个url1从服务器加载一个数据data1，data1中包含了下一个请求的url2</li><li>我们需要通过data1取出url2，从服务器加载数据data2，data2中包含了下一个请求的url3</li><li>我们需要通过data2取出url3，从服务器加载数据data3，data3中包含了下一个请求的url4</li><li>发送网络请求url4，获取最终的数据data4</li></ul></li></ul><p><img src="https://res.cloudinary.com/dt3vcmqdt/image/upload/v1610696951/%E5%9B%BE%E7%89%871_pbphlg.png" alt="回调地狱"></p><ul><li>上面的代码有什么问题吗？<ul><li>正常情况下，不会有什么问题，可以正常运行并且获取我们想要的结果。</li><li>但是，这样额代码难看而且不容易维护。</li><li>我们更加期望的是一种更加优雅的方式来进行这种异步操作。</li></ul></li><li><p>如何做呢？就是使用Promise。</p><ul><li>Promise可以以一种非常优雅的方式来解决这个问题。</li></ul></li><li><p>我们先来看看Promise最基本的语法。</p><ul><li>这里，我们用一个定时器来模拟异步事件： <img src="https://res.cloudinary.com/dt3vcmqdt/image/upload/v1610697335/%E5%9B%BE%E7%89%872_tsnnrr.png" alt=""></li><li>假设下面的data是从网络上1秒后请求的数据,console.log就是我们的处理方式,这是我们过去的处理方式.</li></ul></li><li>我们将它换成Promise代码.<br><img src="https://res.cloudinary.com/dt3vcmqdt/image/upload/v1610697335/%E5%9B%BE%E7%89%873_zr0owz.png" alt=""><ul><li>这个例子会让我们感觉脱裤放屁，多此一举</li><li>首先，下面的Promise代码明显比上面的代码看起来还要复杂。</li><li>其次，下面的Promise代码中包含的resolve、reject、then、catch都是些什么东西？</li><li>我们先不管第一个复杂度的问题，因为这样的一个屁大点的程序根本看不出来Promise真正的作用。</li></ul></li><li>我们先来认认真真的读一读这个程序到底做了什么？<ul><li>new Promise很明显是创建一个Promise对象</li><li>小括号中((resolve, reject) =&gt; {})也很明显就是一个函数，而且我们这里用的是之前刚刚学习过的箭头函数。<ul><li>但是resolve, reject它们是什么呢？</li><li>我们先知道一个事实：在创建Promise时，传入的这个箭头函数是固定的（一般我们都会这样写）</li><li>resolve和reject它们两个也是函数，通常情况下，我们会根据请求数据的成功和失败来决定调用哪一个。</li></ul></li><li>成功还是失败？<ul><li>如果是成功的，那么通常我们会调用resolve(messsage)，这个时候，我们后续的then会被回调。</li><li>如果是失败的，那么通常我们会调用reject(error)，这个时候，我们后续的catch会被回调。 </li></ul></li></ul></li><li><p>OK，这就是Promise最基本的使用了。</p></li><li><p>首先, 当我们开发中有异步操作时, 就可以给异步操作包装一个Promise </p><ul><li>异步操作之后会有三种状态<br><img src="https://res.cloudinary.com/dt3vcmqdt/image/upload/v1610698583/%E5%9B%BE%E7%89%874_lmdg1f.png" alt=""></li></ul></li><li><p>我们一起来看一下这三种状态:</p><ul><li>pending：等待状态，比如正在进行网络请求，或者定时器没有到时间。</li><li>fulfill：满足状态，当我们主动回调了resolve时，就处于该状态，并且会回调.then()</li><li>reject：拒绝状态，当我们主动回调了reject时，就处于该状态，并且会回调.catch()<br><img src="https://res.cloudinary.com/dt3vcmqdt/image/upload/v1610698583/%E5%9B%BE%E7%89%875_zcsfho.png" alt=""></li></ul></li><li><p>我们在看Promise的流程图时，发现无论是then还是catch都可以返回一个Promise对象。</p></li><li>所以，我们的代码其实是可以进行链式调用的：</li><li><p>这里我们直接通过Promise包装了一下新的数据，将Promise对象返回了</p><ul><li>Promise.resovle()：将数据包装成Promise对象，并且在内部回调resolve()函数</li><li>Promise.reject()：将数据包装成Promise对象，并且在内部回调reject()函数<br><img src="https://res.cloudinary.com/dt3vcmqdt/image/upload/v1610699988/JS/Promise/%E5%9B%BE%E7%89%876_zmu0xz.png" alt=""></li></ul></li><li><p>简化版代码：</p><ul><li>如果我们希望数据直接包装成Promise.resolve，那么在then中可以直接返回数据</li><li>注意下面的代码中，我讲return Promise.resovle(data)改成了return data</li><li>结果依然是一样的<br><img src="https://res.cloudinary.com/dt3vcmqdt/image/upload/v1610700068/JS/Promise/%E5%9B%BE%E7%89%877_fng3lp.png" alt=""></li></ul><h5 id="Promise-基础使用到此就结束了-，后续跟新Promise封装Axios-！"><a href="#Promise-基础使用到此就结束了-，后续跟新Promise封装Axios-！" class="headerlink" title="Promise 基础使用到此就结束了 ，后续跟新Promise封装Axios ！"></a>Promise 基础使用到此就结束了 ，后续跟新Promise封装Axios ！</h5></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue - VueX 学习手记</title>
      <link href="2021/01/15/Vue/VueX/"/>
      <url>2021/01/15/Vue/VueX/</url>
      
        <content type="html"><![CDATA[<h3 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h3><p>本篇文章更像是我学习vuex的一个笔记，学习的资源主要是来自官方文档教程，官方教程已经讲的比较细致了，部分地方也有自己不理解的地方，所以也查过其他资料来辅助自己理解，本手记在官方的教程上加了一些自己的补充内容，希望能给你带来一些参考价值，另外也感谢互联网上其他分享知识的大佬，让我少走了些弯路！如果文章有理解不到位的地方，还请各位多批评指正！</p><hr><h3 id="二、Vuex之初体验"><a href="#二、Vuex之初体验" class="headerlink" title="二、Vuex之初体验"></a>二、Vuex之初体验</h3><hr><h5 id="为何使用Vuex"><a href="#为何使用Vuex" class="headerlink" title="为何使用Vuex"></a>为何使用Vuex</h5><p>使用Vue开发的过程中，我们经常会遇到一个状态可能会在多个组件之间使用，比如我们在做项目时使用到的用户的信息，什么昵称、头像这些，这些信息会在不同的组件用到，一旦改变这些状态，我们希望其他组件也跟随变化，比如用户充值了100元，或者改变了昵称，所以这个时候就需要状态管理模式来集中管理，关于Vuex的详细介绍可以移步到官网。</p><h5 id="学习之前的准备"><a href="#学习之前的准备" class="headerlink" title="学习之前的准备"></a>学习之前的准备</h5><p>本次我的学习都是在官方提供的脚手架搭建的项目下学习的，关于脚手架的使用本次就不再赘述，可以移步到Vue CLI，在使用Vue CLI生成的项目时会让你选择store，选择了后会在页面给你生成一个store.js，这就是最初的store，里面结构如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="三、State"><a href="#三、State" class="headerlink" title="三、State"></a>三、State</h3><p>Vuex的核心就是仓库store，这个store实例会被注入到所有子组件里面，里面的state属性保存着我们的状态，比如我们定义一个状态count：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">10</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>这样我们就有一个集中管理的状态count，那其他组件如何取到这个count呢，可以计算属性来获得：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="function"><span class="title">count</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。通过计算属性，我们就可以在模板里面使用模板语法来调用count了，如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><br>mapState有时候需要获取多个状态，但是使用计算属性会调用多次，显得麻烦，这里借助mapState方法来获取state。<br>使用mapState需要引入该方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br></pre></td></tr></table></figure><br>注意：这里使用了mapState方法后，computed的写法有点区别，比如默认情况你的computed属性是这样写的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">    msg: <span class="string">&#x27;hello &#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">computed: &#123;</span><br><span class="line">  <span class="function"><span class="title">msg</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.msg + <span class="string">&#x27;world!&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>那么你使用了mapState后需要这样写computed，把msg()放入mapState，不然会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">    msg: <span class="string">&#x27;hello &#x27;</span>,</span><br><span class="line">    localCount: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">computed: mapState(&#123;</span><br><span class="line">  <span class="function"><span class="title">msg</span>(<span class="params"></span>)</span> &#123;  <span class="comment">// 最初的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.msg + <span class="string">&#x27;world!&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 使用mapState从store中引入state</span></span><br><span class="line">  <span class="function"><span class="title">count</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.count;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">name</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.firstName + <span class="string">&#x27; &#x27;</span> + state.lastName;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mixCount</span>(<span class="params">state</span>)</span> &#123; <span class="comment">// 结合store和组件状态进行计算</span></span><br><span class="line">    <span class="keyword">return</span> state.count + <span class="built_in">this</span>.localCount;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>如果你使用了展开运算符…，那么computed属性不需要改造，按正常写法写<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123; <span class="comment">// 使用展开的话可以按这种方式写，否则要使用另外一种方式，不然要报错</span></span><br><span class="line">  <span class="function"><span class="title">msg</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.msg;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 这里返回一个状态count，</span></span><br><span class="line">  <span class="comment">// 返回多个你可以这样写...mapState([&#x27;count&#x27;, &#x27;firstName&#x27;, &#x27;lastName&#x27;])</span></span><br><span class="line">  ...mapState([<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h3 id="四、Getter"><a href="#四、Getter" class="headerlink" title="四、Getter"></a>四、Getter</h3><p>getter就是对状态进行处理的提取出来的公共部分，当状态要进行筛选这些操作时，我们可以通过getter处理过后再返回给组件使用，比如我们在state部分定义了一个list数组：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>我们想要筛选出数组里面的偶数然后再在组件里面使用，那么筛选的这个工作可以放在getter里面来完成。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123; <span class="comment">//  这个主要是对状态的处理，相当于把状态处理的方法抽成公共部分来管理了</span></span><br><span class="line">    <span class="function"><span class="title">modifyArr</span>(<span class="params">state</span>)</span> &#123; <span class="comment">// 一般化getter</span></span><br><span class="line">      <span class="keyword">return</span> state.list.filter(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">getLength</span>(<span class="params">state, getter</span>)</span> &#123; <span class="comment">// 方法里面传getter，调用modifyArr来计算长度</span></span><br><span class="line">      <span class="keyword">return</span> getter.modifyArr.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>之后再在其他组件的computed里面去调用getter来获取想要的状态<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    <span class="function"><span class="title">list</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.$store.getters.modifyArr;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>mapGetters<br>mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性，当我们想在组件里面引入多个getter时，可以使用mapGetter：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapGetters&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br></pre></td></tr></table></figure><br>比如像刚才在在上面定义的modifyArr，getLength。我们想引入这个两个并获取其值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapGetter([<span class="string">&#x27;modifyArr&#x27;</span>, <span class="string">&#x27;getLength&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>你当然可以为其指定别名，不一定非得用store里面getters定义的名字：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  mapGetter(&#123;</span><br><span class="line">    arr: <span class="string">&#x27;modifyArr&#x27;</span>,   <span class="comment">// 把 `this.arr` 映射为 `this.$store.getters.modifyArr`,下面同理</span></span><br><span class="line">    length: <span class="string">&#x27;getLength&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果你的computed属性包含其他计算方法，那你就只能使用展开运算符的写法，这里跟mapState有点区别，其他计算属性如果写在mapGetter里面会报错，说不存在的getter，所以用以下的写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="function"><span class="title">msg</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.num * <span class="number">10</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...mapGetters([</span><br><span class="line">    <span class="string">&#x27;modifyArr&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;getLength&#x27;</span></span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>或者指定别名<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123; </span><br><span class="line">  <span class="function"><span class="title">msg</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.num * <span class="number">10</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...mapGetters(&#123;</span><br><span class="line">    getList: <span class="string">&#x27;modifyArr&#x27;</span>,</span><br><span class="line">    length: <span class="string">&#x27;getLength&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后再模板里面调用：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>mapGetters的使用演示<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的数字：&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的数组长度为：&#123;&#123; length &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in getList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="五、Mutation"><a href="#五、Mutation" class="headerlink" title="五、Mutation"></a>五、Mutation</h3><p>当我们需要修改store里面的状态时，我们不是在组件里面直接去修改它们，而是通过mutation里面的方法来进行修改，这样有利于追踪状态的改变。<br>比如state里面有一个count变量，我们点击加减按钮来控制它的值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    state.count++;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">reduce</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    state.count--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><br>在其他组件里面，我们通过定义methods并绑定时间来触发改变，这里需要使用commit：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;add&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">reduce</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;reduce&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>提交载荷<br>这个就是在commit时提交额外的参数，比如我传了额外的值加到count上面：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  <span class="function"><span class="title">loadAdd</span>(<span class="params">state, payload</span>)</span> &#123;  <span class="comment">// 提交载荷，额外参数</span></span><br><span class="line">    state.count += payload;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><br>然后再组件里面使用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">loadAdd</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;loadAdd&#x27;</span>, <span class="number">100</span>); <span class="comment">// 传递额外参数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>再这里官方文档建议载荷（也就是那个额外参数）最好使用对象来传，这样可以包含多个字段并且记录的 mutation 会更易读，像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&#x27;loadAdd&#x27;</span>, &#123;</span><br><span class="line">  extraCount: <span class="number">100</span></span><br><span class="line">&#125;); <span class="comment">// 传递额外参数</span></span><br></pre></td></tr></table></figure><br>调用commit时我们也可以把所有参数写在一个对象里面：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.commit( &#123;</span><br><span class="line">  type: <span class="string">&#x27;addLoad&#x27;</span></span><br><span class="line">  extraCount: <span class="number">100</span></span><br><span class="line">&#125;); <span class="comment">// 传递额外参数</span></span><br></pre></td></tr></table></figure><br>Mutation 需遵守 Vue 的响应规则<br>这个主要是说你再开发过程中需要向state里面添加额外数据时，需要遵循响应准则。<br>这里我直接照搬官方文档的说明：<br>Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：</p><p>最好提前在你的 store 中初始化好所有所需属性。</p><p>当需要在对象上添加新属性时，你应该使用 Vue.set(obj, ‘newProp’, 123), 或者以新对象替换老对象。例如，利用 stage-3 的对象展开运算符</p><p>我们可以这样写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state.obj = &#123; ...state.obj, <span class="attr">newProp</span>: <span class="number">123</span> &#125;</span><br></pre></td></tr></table></figure><br>还是举个栗子：<br>我在mutation里面声明了一个方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">addNewState</span>(<span class="params">state, payload</span>)</span> &#123; <span class="comment">// 我打算再这儿添加新的属性到state</span></span><br><span class="line">  <span class="comment">// Vue.set(state, &#x27;newProp&#x27;, &#x27;添加一个新值！&#x27;); // 这是一种写法</span></span><br><span class="line">  <span class="comment">// 这种写法用新对象替换老对象</span></span><br><span class="line">  <span class="comment">// state= &#123;...state, newProp: &#x27;添加一个新值！&#x27;&#125; // 这个玩意儿不管用了，用下面的replaceState()方法</span></span><br><span class="line">  <span class="built_in">this</span>.replaceState(&#123;...state, <span class="attr">newProp</span>: <span class="string">&#x27;添加一个新值！&#x27;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后再组件里面去调用，定义一个method：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">addNewProp</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;addNewState&#x27;</span>, &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样再执行了这个方法后，会及时更新到state，再组件的computed属性里面定义：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">newMsg</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.newProp || <span class="string">&#x27;还没添加新值&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在模板里面即时展示，并且不会影响其他状态：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>添加的新值：&#123;&#123; newMsg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addNewProp&quot;</span>&gt;</span>添加新值<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br>Mutation 必须是同步函数<br>下面这种写法必须避免（直接官方例子加持）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  someMutation (state) &#123;</span><br><span class="line">    api.callAsyncMethod(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>mapMutations<br>这个跟前面的那几个函数一个道理，都是为了简化调用，使用方法如下：<br>import {mapMutations} from ‘vuex’;<br>然后在组件的methods里面使用，这里使用官方代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      <span class="string">&#x27;increment&#x27;</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapMutations` 也支持载荷：</span></span><br><span class="line">      <span class="string">&#x27;incrementBy&#x27;</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&#x27;incrementBy&#x27;, amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      add: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="六、Action"><a href="#六、Action" class="headerlink" title="六、Action"></a>六、Action</h3><p>Action 类似于 mutation，不同在于：</p><p>Action 提交的是 mutation，而不是直接变更状态。<br>Action 可以包含任意异步操作。<br>前面说过mutation只能包含同步事务，所以在处理异步事务就需要Action，通过Action控制了异步这一过程，之后再去调用mutation里面的方法来改变状态。<br>这里我直接贴代码来一目了然，首先我定义了一个状态product：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">state: &#123;</span><br><span class="line">  product: <span class="string">&#x27;car&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">然后再mutation中定义一个方法：</span><br><span class="line"><span class="function"><span class="title">changeProduct</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">  state.product = payload.change;</span><br><span class="line">&#125;</span><br><span class="line">在action中定义：</span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="function"><span class="title">changeProduct</span>(<span class="params">context, payload</span>)</span> &#123; <span class="comment">// 这个context是一个与 store 实例具有相同方法和属性的对象</span></span><br><span class="line">    <span class="comment">// 调用mutation里的changeProduct方法</span></span><br><span class="line">    <span class="comment">// context.commit(&#x27;changeProduct&#x27;, &#123;change: &#x27;ship&#x27;&#125;);</span></span><br><span class="line">    <span class="comment">// 改成异步方式</span></span><br><span class="line">    <span class="comment">// setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   context.commit(&#x27;changeProduct&#x27;, &#123;change: &#x27;ship&#x27;&#125;);</span></span><br><span class="line">    <span class="comment">// &#125;, 1500)</span></span><br><span class="line">    <span class="comment">// 使用载荷</span></span><br><span class="line">    <span class="keyword">let</span> temp = <span class="string">&#x27;ship+&#x27;</span> + payload.extraInfo; </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      context.commit(<span class="string">&#x27;changeProduct&#x27;</span>, &#123;<span class="attr">change</span>: temp&#125;);</span><br><span class="line">    &#125;, <span class="number">1500</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在组件methods中定义事件触发分发：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">selectProduct</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// this.$store.dispatch(&#x27;changeProduct&#x27;)</span></span><br><span class="line">    <span class="comment">// 载荷方式分发</span></span><br><span class="line">    <span class="comment">// this.$store.dispatch(&#x27;changeProduct&#x27;, &#123;</span></span><br><span class="line">    <span class="comment">//   extraInfo: &#x27;sportcar&#x27;</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// 或者这种</span></span><br><span class="line">    <span class="built_in">this</span>.$store.dispatch(&#123;</span><br><span class="line">      type: <span class="string">&#x27;changeProduct&#x27;</span>,</span><br><span class="line">      extraInfo: <span class="string">&#x27;-&gt;sportcar&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><br>这样一个简易的action就完成了！<br>mapActions<br>这里就不再赘述了，看名字就知道跟前面几个叫map开头的辅助函数类似，用来映射action里面的方法，这里也直接贴官方代码了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapActions&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="string">&#x27;increment&#x27;</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">      <span class="string">&#x27;incrementBy&#x27;</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#x27;incrementBy&#x27;, amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      add: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>有时候我们想知道action里面异步执行后的状态然后再去修改其他信息，这个可以借助Promise来实现。这里在state里面声明一个状态：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">state: &#123;</span><br><span class="line">  userInfo: &#123; <span class="comment">// 这个变量用来测试组合变量</span></span><br><span class="line">    name: <span class="string">&#x27;lee&#x27;</span>,</span><br><span class="line">    age: <span class="number">23</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接着声明mutation:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">    <span class="comment">// 以下用来测试组合action</span></span><br><span class="line">    <span class="function"><span class="title">changeInfo</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">      state.userInfo.name = <span class="string">&#x27;lee haha&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>声明action：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="function"><span class="title">changeInfo</span>(<span class="params">context, payload</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;changeInfo&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这时我们在组件里面定义方法去派发这个action：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    status: <span class="string">&#x27;信息还没修改！&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">modifyInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;changeInfo&#x27;</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.status = <span class="string">&#x27;信息修改成功&#x27;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>模板展示：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>组合action<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; status &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; info.name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;modifyInfo&quot;</span>&gt;</span>修改信息<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><br>当我们点击修改信息后，就会派发action，当修改成功的时候会同步修改上面说的展示信息。<br>当然其他定义的action方法也可以互相使用，这里直接贴官方代码了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">&#x27;someMutation&#x27;</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="string">&#x27;actionA&#x27;</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">&#x27;someOtherMutation&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="七、Module"><a href="#七、Module" class="headerlink" title="七、Module"></a>七、Module</h3><p>模块这部分正如其名，当所有状态集中在一个对象中时，会变的相当臃肿，这个时候就需要模块的管理办法。这里我还是用代码来说明，比如我在store里面定义了两个模块：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义的模块A</span></span><br><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    name: <span class="string">&#x27;lee&#x27;</span>,</span><br><span class="line">    age: <span class="number">23</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义模块B</span></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    name: <span class="string">&#x27;wang&#x27;</span>,</span><br><span class="line">    age: <span class="number">22</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后再Vuex里面声明模块：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    ma: moduleA,</span><br><span class="line">    mb: moduleB</span><br><span class="line">  &#125;,</span><br><span class="line">  state: &#123;</span><br><span class="line">    ........... <span class="comment">// 其他状态</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>这样一来，如果我们想要在组件里面访问其他模块的状态，可以这样，比如这里我想调用B模块里的状态：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="function"><span class="title">msg</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$store.mb; <span class="comment">// 这里返回的是：&#123;name: &#x27;wang&#x27;, age: 22&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>关于模块内部的局部状态，这里跟普通的store用法没有多大的区别，主要区别以下外部传进来的状态，比如对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState，这里截取官方代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actions: &#123;</span><br><span class="line">    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((state.count + rootState.count) % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  getters: &#123;</span><br><span class="line">    sumWithRootCount (state, getters, rootState) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>那么对于getters、mutations、actions里面的方法我们像基本的store那样调用就可以了，不存在作用域限制，还是贴代码栗子吧，下面是我在store.js里面定义的模块B：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    name: <span class="string">&#x27;wang&#x27;</span>,</span><br><span class="line">    age: <span class="number">22</span>,</span><br><span class="line">    desc: <span class="string">&#x27;nope&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="function"><span class="title">modifyDesc</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">      state.desc = payload.newMsg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在组件里面，我定义了以下内容：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>7、module使用示例<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>名字：&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>描述：&#123;&#123; desc &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>修改描述<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      name: <span class="built_in">this</span>.$store.state.mb.name,</span></span><br><span class="line"><span class="javascript">      <span class="comment">// desc: this.$store.state.mb.desc 注意这个如果涉及到要在store里面会被改变的状态，一定要写在</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// computed属性里面，不然不能及时反馈到视图上</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">desc</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.mb.desc;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;modifyDesc&#x27;</span>, &#123;<span class="attr">newMsg</span>: <span class="string">&#x27;lao wang is beautiful!&#x27;</span>&#125;);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><br>这样，就可以调用mutation里面的方法了，getters和actions同理</p><p>命名空间模块<br>默认情况下，mutations、actions、getters这些都是注册在全局上面的，你可以直接调用，如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。<br>首先我新建一个js文件用来声明模块C：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 这个文件用来声明模块C</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> moduleC = &#123;</span><br><span class="line">  namespaced: <span class="literal">true</span>,</span><br><span class="line">  state: &#123;</span><br><span class="line">    name: <span class="string">&#x27;moduleC&#x27;</span>,</span><br><span class="line">    desc: <span class="string">&#x27;这是模块C，用来测试命名空间的！&#x27;</span>,</span><br><span class="line">    list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    <span class="function"><span class="title">filterList</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.list.filter(<span class="function">(<span class="params">item, index, arrSelf</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item % <span class="number">2</span> !== <span class="number">0</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="function"><span class="title">modifyName</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">      state.name = payload.newName;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后在store.js里面引入：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; moduleC &#125; <span class="keyword">from</span> <span class="string">&#x27;./module_c.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    mc: moduleC</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>要想这个模块成为带有命名空间的模块，在上面声明属性namespaced: true就可以了，那么里面的mutations、getters和actions里面的方法的调用就要多走一层路径，比如我在组件里面去调用mutations里面的方法（getters和actions同理）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">modify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// this.$store.commit(&#x27;mc/modifyName&#x27;, &#123;</span></span><br><span class="line">    <span class="comment">//   newName: &#x27;命名空间模块C&#x27;</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="built_in">this</span>.$store.commit(&#123;</span><br><span class="line">      type: <span class="string">&#x27;mc/modifyName&#x27;</span>,</span><br><span class="line">      newName: <span class="string">&#x27;命名空间模块C&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当然模块里面再嵌套模块也可以，路径要不要多走一层主要看你的namespaced: true有没有声明，这里贴一下官方的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    account: &#123;</span><br><span class="line">      namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模块内容（module assets）</span></span><br><span class="line">      state: &#123; ... &#125;, <span class="comment">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span></span><br><span class="line">      getters: &#123;</span><br><span class="line">        isAdmin () &#123; ... &#125; <span class="comment">// -&gt; getters[&#x27;account/isAdmin&#x27;]</span></span><br><span class="line">      &#125;,</span><br><span class="line">      actions: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; dispatch(&#x27;account/login&#x27;)</span></span><br><span class="line">      &#125;,</span><br><span class="line">      mutations: &#123;</span><br><span class="line">        login () &#123; ... &#125; <span class="comment">// -&gt; commit(&#x27;account/login&#x27;)</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 嵌套模块</span></span><br><span class="line">      modules: &#123;</span><br><span class="line">        <span class="comment">// 继承父模块的命名空间</span></span><br><span class="line">        myPage: &#123;</span><br><span class="line">          state: &#123; ... &#125;,</span><br><span class="line">          getters: &#123;</span><br><span class="line">            profile () &#123; ... &#125; <span class="comment">// -&gt; getters[&#x27;account/profile&#x27;]</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进一步嵌套命名空间</span></span><br><span class="line">        posts: &#123;</span><br><span class="line">          namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">          state: &#123; ... &#125;,</span><br><span class="line">          getters: &#123;</span><br><span class="line">            popular () &#123; ... &#125; <span class="comment">// -&gt; getters[&#x27;account/posts/popular&#x27;]</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>在带命名空间的模块内访问全局内容<br>如果想要在模块内部的getters、mutations和actions里面访问到全局的内容，这儿Vuex已经封装好了，你只需要多传几个参数即可。官方演示来一波，简单明了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">modules: &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    namespaced: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    getters: &#123;</span><br><span class="line">      <span class="comment">// 在这个模块的 getter 中，`getters` 被局部化了</span></span><br><span class="line">      <span class="comment">// 你可以使用 getter 的第四个参数来调用 `rootGetters`</span></span><br><span class="line">      someGetter (state, getters, rootState, rootGetters) &#123;</span><br><span class="line">        getters.someOtherGetter <span class="comment">// -&gt; &#x27;foo/someOtherGetter&#x27;</span></span><br><span class="line">        rootGetters.someOtherGetter <span class="comment">// -&gt; &#x27;someOtherGetter&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      someOtherGetter: <span class="function"><span class="params">state</span> =&gt;</span> &#123; ... &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    actions: &#123;</span><br><span class="line">      <span class="comment">// 在这个模块中， dispatch 和 commit 也被局部化了</span></span><br><span class="line">      <span class="comment">// 他们可以接受 `root` 属性以访问根 dispatch 或 commit</span></span><br><span class="line">      someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;</span><br><span class="line">        getters.someGetter <span class="comment">// -&gt; &#x27;foo/someGetter&#x27;</span></span><br><span class="line">        rootGetters.someGetter <span class="comment">// -&gt; &#x27;someGetter&#x27;</span></span><br><span class="line"></span><br><span class="line">        dispatch(<span class="string">&#x27;someOtherAction&#x27;</span>) <span class="comment">// -&gt; &#x27;foo/someOtherAction&#x27;</span></span><br><span class="line">        dispatch(<span class="string">&#x27;someOtherAction&#x27;</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; &#x27;someOtherAction&#x27;</span></span><br><span class="line"></span><br><span class="line">        commit(<span class="string">&#x27;someMutation&#x27;</span>) <span class="comment">// -&gt; &#x27;foo/someMutation&#x27;</span></span><br><span class="line">        commit(<span class="string">&#x27;someMutation&#x27;</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; &#x27;someMutation&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      someOtherAction (ctx, payload) &#123; ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在模块里面使用辅助函数mapState、mapGetters、mapMutations和mapActions<br>由于存在命名空间，在组件里面采用上面的写法会出现问题，这里要想使用辅助函数来映射模块里面的东西需要指定空间名称来告诉辅助函数应该去哪儿找这些。<br>这儿我以上面我的C模块为例，首先对于mapSatate函数可以这样玩，我在全局的modules里面声明了mc，那我的空间名称就是mc：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(<span class="string">&#x27;mc&#x27;</span>, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;desc&#x27;</span>]) <span class="comment">// 这里模块里面要使用辅助函数的话要多传一个参数才行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后在模版里面写name，desc即可，或者可以这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ...mapState(<span class="string">&#x27;mc&#x27;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">name</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.name;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">desc</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.desc;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><br>对于actions、mutations和getters方式类似，主要是要指定空间名称，比如对于声明的mutations：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  ...mapMutations(<span class="string">&#x27;mc&#x27;</span>, [<span class="string">&#x27;modifyName&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果你确实不想在每个辅助函数里写空间名称，Vuex也提供了其它办法，使用createNamespacedHelpers创建基于某个命名空间辅助函数，它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; mapState, mapMutations &#125; = createNamespacedHelpers(<span class="string">&#x27;mc&#x27;</span>);</span><br></pre></td></tr></table></figure><br>这样你在写辅助函数的时候就不需要单独指定空间名称了。<br>其它类似，恕我就不再赘述了！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
